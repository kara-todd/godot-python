from ._api import Isengard, get_parent
from ._graph import Rule, Target

__all__ = (
    "Isengard",
    "get_parent",
    "Rule",
    "Target",
)

# import os
# import asyncio
# import sqlite3
# from enum import Enum
# from contextvars import ContextVar
# from pathlib import Path
# from typing import Dict, List, Set, Callable, Union, Optional, Any
# import inspect
# from dataclasses import dataclass
# from contextlib import asynccontextmanager


# # class SQLiteDB:
# #     def __init__(self, con):
# #         self.con = con

# #     async def execute(self):
# #         pass

# #     @asynccontextmanager
# #     @classmethod
# #     async def run(cls, path):
# #         con = sqlite3.connect('example.db')
# #         try:
# #             yield cls(con)

# #         finally:
# #             con.close()


# _current_dir: ContextVar[Path] = ContextVar('current_dir')


# RuleFnSignature = Callable[[], None]  # TODO
# MetaRuleFnSignature = Callable[[], None]  # TODO


# @dataclass()
# class Item:
#     pass


# @dataclass()
# class RuleItem(Item):
#     pass


# @dataclass()
# class ConfigItem(Item):
#     value: Any


# class IsengardError(Exception):
#     pass


# class IsengardConsistencyError(IsengardError):
#     pass


# class IsengardDefinitionError(IsengardError):
#     pass


# class EdgeType(Enum):
#     FILE = "File"
#     FOLDER = "Folder"
#     VIRTUAL = "Virtual"


# class Edge(str):
#     __slots__ = ()

#     def __new__(cls, name):
#         if len(name) < 2:
#             raise ValueError("Invalid edge name")
#         if name[0] not in "/#@":
#             ValueError("Invalid edge type: must be `/` for folder, `#` for file or `@` for virtual edge")
#         return super().__new__(cls, name)

#     @property
#     def type(self):
#         if self[0] == "/":
#             return EdgeType.FOLDER
#         elif self[0] == "#":
#             return EdgeType.FILE
#         else:  # "@"
#             return EdgeType.VIRTUAL


# @dataclass()
# class Rule:
#     name: str
#     outputs: List[Edge]
#     inputs: List[Edge]
#     fn: Callable


# # class RulesGraph:
# #     def __init__(self):
# #         self.rules: List[Rule] = []
# #         self.output_to_rule: Dict[Edge, Rule] = {}
# #         self.rule_dependencies: Dict[Rule, Set[Rule]] = {}

# #     def add_rule(self, rule: Rule) -> None:
# #         deps = set()
# #         for input in rule.inputs:
# #             try:
# #                 dep = self.output_to_rule[input]

# #             except IndexError:
# #                 pass

# #         for output in rule.outputs:
# #             self.rules.append(rule)
# #             existing = self.output_to_rule.setdefault(output, rule)
# #             if existing is not rule:
# #                 raise IsengardConsistencyError(f"Edge {output} can be generated by multiple rules: {existing} and {rule}")


# def check_consistency(name: Edge, rules: List[Rule]) -> None:
#     return


# async def run(name: Edge, rules: List[Rule], workdir: Path, dbpath: Path) -> Any:
#     check_consistency(name, rules)

#     async def _run(name, rules, results, stack):
#         assert name not in stack
#         stack = {*stack, name}
#         rule = deps_map.get(name)
#         assert rule

#         inputs = []
#         for input in rule.inputs:
#             if isinstance(input, RuleItem):
#                 inputs.append(await _run(input.name, rules, results))
#             else:
#                 inputs.append(input.value)

#         if inspect.iscoroutinefunction(rule.fn):
#             results = await rule.fn(**inputs)
#         else:
#             results = rule.fn(**inputs)
#         assert len(results) == len(rule.outputs)
#         for result, output in zip(results, rule.outputs):
#             results[output.name] = result

#         return result[name]

#     results = {}
#     stack = set()
#     return _run(name, rules, results, stack)


# def extract_virtual_edges_from_fn(fn: Callable):
#     edges: List[Edge] = []
#     signature = inspect.signature(fn)
#     for param in signature.parameters.values():
#         if not param.empty:
#             raise IsengardDefinitionError(f"Rule {fn} cannot have default value to parameters")
#         if not param.kind == param.VAR_POSITIONAL:
#             raise IsengardDefinitionError(f"Rule {fn} cannot have *args parameter")
#         if not param.kind == param.VAR_KEYWORD:
#             raise IsengardDefinitionError(f"Rule {fn} cannot have **kwargs parameter")
#         edges.append(f"{param.value}@")
#     return edges


# class Isengard:
#     def __init__(self, self_file: Union[str, Path], db: Union[str, Path]=".isengard.sqlite"):
#         self.self_file = Path(self_file).absolute()
#         self.base_dir = self.self_file.parent
#         if not isinstance(db, Path):
#             db = Path(db)
#         if not db.is_absolute():
#             db = self.base_dir / db
#         self.db_file = db
#         # self.dbcon = sqlite3.connect(str(db))
#         self.rules: List[Rule] = []
#         self.meta_rules: Dict[str, Callable] = {}

#     def rule(self, targets=None, target=None, sources=None, source=None, name=None):
#         if target is not None:
#             if targets is not None:
#                 raise IsengardDefinitionError("Cannot define both `target` and `targets` parameters")
#             else:
#                 targets = [target]
#         elif targets is None:
#             raise IsengardDefinitionError("One of `target` or `targets` parameters is mandatory")

#         if source is not None:
#             if sources is not None:
#                 raise IsengardDefinitionError("Cannot define both `source` and `sources` parameters")
#             else:
#                 sources = [source]
#         elif sources is None:
#             sources = []

#         def wrapper(fn):
#             all_targets = [*targets, *extract_virtual_edges_from_fn(fn)]
#             rule = Rule(name=name or fn.__name__, outputs=all_targets, inputs=sources, fn=fn)
#             self.rules.append(Rule(name, fn))
#             return fn

#         return wrapper

#     def meta_rule(self, fn: MetaRuleFnSignature) -> MetaRuleFnSignature:
#         try:
#             existing = self.meta_rules[fn.__name__]
#             raise RuntimeError(f"Meta-rule {fn.__name__} already exists ({existing})")
#         except KeyError:
#             self.meta_rules.append(fn)
#         return fn

#     def __getattr__(self, name):
#         try:
#             return self.meta_rules[name]
#         except KeyError as exc:
#             raise AttributeError from exc

#     def clone(self):
#         raise NotImplementedError("TODO !")

#     def subdir(self, subdir: str, filename: Optional[str] = None) -> None:
#         subdir_path = self.self_file.parent / subdir / (filename or self.self_file.name)
#         isg = Isengard(subdir_path)
#         token = _parent.set(isg)
#         try:
#             exec(subdir_path.read_text())
#             self.rules += isg.rules
#         finally:
#             token.reset()
#         # if subdir_path.read

#     def run(self, name: str) -> Any:
#         return await run(name, self.rules, self.workdir, self.dbpath)


# _parent: ContextVar[Isengard] = ContextVar('context')


# def get_parent() -> Isengard:
#     try:
#         return _parent.get()
#     except LookupError as exc:
#         raise RuntimeError("Not in a subdir !") from exc
