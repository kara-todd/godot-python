# from dataclasses import dataclass
from typing import Callable, Set, List, Dict, Union


# TODO
class Target(str):
    def __new__(cls, data):
        if isinstance(data, Target):
            return data
        else:
            return super(Target, cls).__new__(cls, data)


TargetLike = Union[Target, str]
RuleFnSignature = Callable  # TODO


class Rule:
    __slots__ = ("name", "outputs", "inputs")

    def __init__(self, name: str, outputs: List[TargetLike], inputs: List[TargetLike], fn: RuleFnSignature):
        self.name = name
        self.outputs = [Target(x) for x in outputs]
        self.inputs = [Target(x) for x in inputs]


class RulesGraph:
    pass


# from . import IsengardConsistencyError, Rule, Target


# @dataclass()
# class TargetNode:
#     generator: "RuleNode"
#     dependents: Set["RuleNode"]
#     target: Target


# @dataclass()
# class RuleNode:
#     outputs: Set[TargetNode]
#     direct_inputs: Set[TargetNode]
#     all_inputs: Set[TargetNode]
#     rule: Rule


# class Graph:
#     def __init__(self):
#         self.target_nodes: Dict[Target, TargetNode] = {}
#         self.rule_nodes: Dict[str, RuleNode] = {}

#     def add_rule(self, rule: Rule):
#         deps = set()
#         all_inputs: Set[TargetNode] = set()
#         for input in rule.inputs:
#             try:
#                 dep = self.output_to_rule[input]
#                 all_inputs |= dep.all_inputs

#             except IndexError:
#                 pass

#         cyclic_targets = rule.outputs - all_inputs
#         if cyclic_targets:
#             raise IsengardConsistencyError(f"Targets {cyclic_targets} in rule {rule} create cyclic dependencies !")

#         RuleNode(
#             all_inputs=all_inputs,
#         )

#         for output in rule.outputs:
#             self.rules.append(rule)
#             existing = self.output_to_rule.setdefault(output, rule)
#             if existing is not rule:
#                 raise IsengardConsistencyError(f"Target {output} can be generated by multiple rules: {existing} and {rule}")
